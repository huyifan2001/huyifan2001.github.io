<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>集合类</title>
      <link href="/Prop/algebra/"/>
      <url>/Prop/algebra/</url>
      
        <content type="html"><![CDATA[<h2 id="different-kings-of-class">Different kings of Class</h2><div class="note info">            <ul><li><strong>Semi-Ring Definition</strong>: A class <span class="math inline">\(\varphi\)</span> of subsets such that<ul><li><span class="math inline">\(\varnothing \in \varphi\)</span></li><li><span class="math inline">\(A,\, B \in \varphi\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A \cap B \in \varphi\)</span></li><li><span class="math inline">\(A,\, B \in \varphi\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A-B = \cup_{i = 1}^{n} E_i\)</span> where <span class="math inline">\(E_i \in \varphi\)</span></li></ul></li><li><strong>Ring Definition</strong>: A class <span class="math inline">\(\mathcal{R}\)</span> of subsets such that<ul><li>First definition: <span class="math inline">\(A,\, B \in \mathcal{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A \cap B \in \mathcal{R}\)</span>, <span class="math inline">\(A \Delta B \in \mathcal{R}\)</span></li><li>Second definition: <span class="math inline">\(A,\, B \in \mathcal{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A \cap B \in \mathcal{R}\)</span>, <span class="math inline">\(A \cup B \in \mathcal{R}\)</span></li><li>Third definition: <span class="math inline">\(A,\, B \in \mathcal{R}\)</span> <span class="math inline">\(\Rightarrow\)</span> <span class="math inline">\(A \cup B \in \mathcal{R}\)</span>, <span class="math inline">\(A - B \in \mathcal{R}\)</span></li></ul></li><li><strong>Algebra Definition</strong><ul><li>Any class of subsets of X that is a ring, and contains X</li></ul></li><li><strong>Sigma Ring(Algebra) Definition</strong>: A class <span class="math inline">\(\mathcal{R}\)</span> of subsets such that<ul><li>The Ring closed under countable unions. Same for Sigma Field(which is also called Borel Field, sigma-algebra)</li></ul></li></ul>          </div><p>Semi-ring 直观例子就是<span class="math inline">\((a,b]\)</span> 组成的集合。以上三个条件显然满足。然而上述定义的<span class="math inline">\((a,b]\)</span>组成的集合并不是一种Ring, 原因在于该类对于<span class="math inline">\(A \Delta B\)</span> 不封闭。更加有趣的是，对于Ring of sets, 同样可以用代数的Ring 来理解。</p><p>Sigma-ring also means it is closed under countable intersections. Which means that both $E_i $ and $ E_i$ are in the set of <span class="math inline">\(\mathcal{R}\)</span> <div class="note info">            <ul><li><strong>Monotone class</strong>: For any Monotone sequence in , its limit is in this class.</li></ul>          </div> Obviously, a ring is a monotone class. Also, if a monotone class is a ring, it is naturally a sigma ring.</p><p>除了Semi Ring以外的上述结构，我们不妨定义为z-class, 对于同一种z-class 都有如下性质（十分重要的性质）：任意同一类z-class 的交都是z-class. 有了这个结论以后，可以立即证明有包含给定类（关于X的子集）的最小z-class. 我们称这个集合是 the z-class generated by X.</p><p>Semi Ring 可以通过一定方式来生成一个 Ring, 具体而言，有如下的定理 <div class="note info">            <p>The ring generated by <span class="math inline">\(\varphi\)</span> can be expressed:<span class="math display">\[E = \cup_{k = 1}^{n} A_k\]</span> where <span class="math inline">\(A_k\)</span> are finite disjoint sets of <span class="math inline">\(\varphi\)</span></p>          </div> 定理的证明是技巧性的。具体来说，只要证明如上定义的交和difference结果都可以表达为上述定义结果即可。</p><p>如果我们已经有了一个Ring, 由它生成的 monotone class 就是这个ring生成的sigma ring. 这是一个非常重要的结论。 <div class="note info">            <h4 id="monotone-class-theorem-for-sets">Monotone class theorem for sets</h4><p>Let <span class="math inline">\(G\)</span> be an algebra of sets and define <span class="math inline">\(M(G)\)</span> to be the smallest monotone class containing <span class="math inline">\(G\)</span> Then <span class="math inline">\(M(G)\)</span> is precisely the 𝜎-algebra generated by <span class="math inline">\(M(G)\)</span></p>          </div></p><p><strong>The proof is relatively difficult.</strong> 直观的思路是，不妨我们在<span class="math inline">\(M(G)\)</span>的每一个元素<span class="math inline">\(F\)</span>的基础上构造集合（也就是满足<span class="math inline">\(E-F\)</span>, <span class="math inline">\(F-E\)</span>, <span class="math inline">\(E \cup F\)</span>, <span class="math inline">\(E \in M(G)\)</span> 都在<span class="math inline">\(M(G)\)</span>中的集合<span class="math inline">\(E\)</span>），组成新的class <span class="math inline">\(\mathcal{Z}(F)\)</span>。这样的构造说明对于任何在<span class="math inline">\(M(G)\)</span>中的元素，都可以找到另一个跟<span class="math inline">\(F\)</span>形成Ring关系的元素。主要说明对任意的<span class="math inline">\(F\)</span>，都可以成立<span class="math inline">\(\mathcal{Z}(F) = M(G)\)</span> 就可以了。证明非常巧妙的地方，就是利用了上述定义的对称性，以及monotone class 的性质。</p>]]></content>
      
      
      <categories>
          
          <category> Prop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Prop introduction</title>
      <link href="/Prop/Prop-intro/"/>
      <url>/Prop/Prop-intro/</url>
      
        <content type="html"><![CDATA[<h3 id="list-of-notes">List of notes</h3><p>现在还是草稿，后续会继续整理排版</p><ul><li><a href="/Prop/sets/">集合运算</a></li><li><a href="/Prop/algebra/">集合类</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Prop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Sets Calculation</title>
      <link href="/Prop/sets/"/>
      <url>/Prop/sets/</url>
      
        <content type="html"><![CDATA[<h2 id="集合运算">集合运算</h2><p>补充一种常用的集合运算：<span class="math inline">\(A \Delta B = (A-B) \cup (B-A)\)</span></p><p>一个比较好用并且在很大程度上跟后面抽代理论相关的一个定理叙述如下，证明是显然的。 <div class="note primary no-icon">            <h4 id="lemma.">Lemma.</h4><p>Given a finite or enumerate union of sets <span class="math inline">\(\cup_{i = 1}^{p}E_i\)</span>, there are subsets <span class="math inline">\(F_i\subset E_i\)</span>, such that the sets F_i are disjoint and <span class="math inline">\(\cup_{i = 1}^{p}E_i = \cup_{i = 1}^{p}F_i\)</span></p>          </div> 这个定理主要在后面 monotone class 与 sigma-ring 的理论中会用到。</p><p>接下来是集合的极限相关的定义。定义如下两个运算：<span class="math display">\[\begin{align*}\lim\sup E_i = \cap_{n = 1}^{\infty}\left(\cup_{i = n}^{\infty}E_i\right) \\\lim\inf E_i = \cup_{n = 1}^{\infty}\left(\cap_{i = n}^{\infty}E_i\right) \end{align*}\]</span> 一种理解方式，<span class="math inline">\(\lim\sup E_i\)</span> 是在给定集合序列中<strong>出现无穷多次</strong>的元素集合，(若元素只出现有限多次，在给定N以后的集合，做并运算的结果都不会有N，不会在这个集合当中; 若给定N以后，在剩下的集合取交集，没有该元素，那么之后的所有集合都不会出现该元素，说明这个元素只出现有限多次)</p><p><span class="math inline">\(\lim\inf E_i\)</span> 是在给定集合序列中<strong>只在有限多个集合中不存在</strong>的元素，(若只在有限多个集合中不存在，那么在给定N以后的元素，做交集结果中都会存在这个元素；若在无限多个集合中不存在，那么在给定N以后的元素，做交集结果中都会不存在这个元素，不会在最终的结果中存在) <div class="note info">            <h4 id="more-information">More information</h4><p><strong>对于这个运算可以直接从符号本身来理解</strong>。In general, when there are multiple objects around which a sequence, function, or set accumulates, the inferior and superior limits extract the smallest and largest of them; the type of object and the measure of size is context-dependent, but the notion of extreme limits is invariant.</p><p>显然，两个运算中内部的Cup的运算干的事情就是提取最大的那个集合，而Cap干的事情实在提取最小的那个集合。而外面的运算，其实在干的是取极限的事情（注意一下，一个是递减序列，用Cap, 一个是递增序列，用Cup）</p>          </div></p><p>很显然，<span class="math inline">\(\lim\inf E_i \subset \lim\sup E_i\)</span>. 说一个集合列收敛，我们想要说明的是 <span class="math inline">\(E = \lim\sup E_i = \lim\inf E_i\)</span></p><p>实际上上面已经提到了集合递增和递减的事情了。实际上，这个性质可以很大程度上化简极限运算的问题。我们后面计算极限的时候常常也是运用这种技巧。具体而言，我们有以下结论。</p><div class="note primary no-icon">            <h4 id="lemma">Lemma</h4><p>If <span class="math inline">\(\{E_i\}\)</span> is increasing, <span class="math inline">\(\cup_{i = n}^{\infty}E_i = \cup_{i = 1}^{\infty}E_i\)</span>, <span class="math inline">\(\cap_{i = n}^{\infty}E_i = E_n\)</span>, obviously, <span class="math display">\[\lim\sup E_i = \lim\inf E_i = \cup_{i = 1}^{\infty}E_i\]</span></p><p>If <span class="math inline">\(\{E_i\}\)</span> is decreasing, <span class="math inline">\(\cup_{i = n}^{\infty}E_i = E_n\)</span>, <span class="math inline">\(\cap_{i = n}^{\infty}E_i = \cap_{i = 1}^{\infty}E_i\)</span>, obviously, <span class="math display">\[\lim\sup E_i = \lim\inf E_i = \cap_{i = 1}^{\infty}E_i\]</span></p>          </div>]]></content>
      
      
      <categories>
          
          <category> Prop </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Basic Knowledge</title>
      <link href="/Opt/basic/"/>
      <url>/Opt/basic/</url>
      
        <content type="html"><![CDATA[<h2 id="预备知识">预备知识</h2><p>从运算角度，可以从另一方面理解锥的意义。定义以下的运算：对于 <span class="math inline">\(\Lambda \subseteq R\)</span>, <span class="math display">\[\Lambda C = \{\lambda c \, |\, \lambda \in \Lambda,\, c \in C \}\]</span> 从锥的定义而言，就是定义了一类的集合，在<span class="math inline">\(\Lambda = R^+\)</span>的乘法运算下，保持不变性。</p><p>一些拓扑的知识不再深究，有兴趣可以读读Rudin第二章，基本上所有的东西自己证明一遍大概都能懂。这部分技巧性很高。</p><h2 id="凸集合分离定理">凸集合分离定理</h2><p>凸集分离定理最重要的一点，在于叙述了一个集合，与一个不在该集合中的点，可以通过一种拓扑性质研究二者关系。具体而言，可以通过以下的例子理解。</p><div class="note default">            <h4 id="exercise-1.1.4">exercise 1.1.4</h4><p>If <span class="math inline">\(A+C \subseteq B+C\)</span>, <span class="math inline">\(B\)</span> is convex and closed, <span class="math inline">\(C\)</span> is bounded, prove <span class="math inline">\(A \subseteq B\)</span></p><p>实际上，上述问题等价于证明 If <span class="math inline">\(C \subseteq B+C\)</span>, <span class="math inline">\(B\)</span> is convex and closed, <span class="math inline">\(C\)</span> is bounded, prove <span class="math inline">\(0 \in B\)</span>. 反证法用凸集分离定理，<span class="math inline">\(\forall b \in B\)</span>, <span class="math inline">\(\exists a\)</span>, $ &lt;a,b&gt; &lt; 0$ 那么很容易得到 <span class="math inline">\(&lt;a, b+c&gt; &lt; &lt;a,c&gt;\)</span>（简单的运算性质）</p>          </div><p>TO BE CONTINUED</p>]]></content>
      
      
      <categories>
          
          <category> Opt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Introduction of Optimization</title>
      <link href="/Opt/OP_intro/"/>
      <url>/Opt/OP_intro/</url>
      
        <content type="html"><![CDATA[<h3 id="list-of-notes">List of notes</h3><p>现在还是草稿，后续会继续整理排版</p><ul><li><a href="/Opt/basic/">基础知识</a></li><li>不等式相关补充</li></ul>]]></content>
      
      
      <categories>
          
          <category> Opt </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WELCOME TO ICARUS&quot;S NET!</title>
      <link href="/uncategorized/index/"/>
      <url>/uncategorized/index/</url>
      
        <content type="html"><![CDATA[<p>一名正在挣扎的大数据学生，似乎对于任何的方向都感兴趣。</p><p>这个假期我会更新优化和实变函数（主要服务高等概率论，不是系统的学习）内容。优化的内容更加靠谱一些。由于实变函数是我自学的，错的地方肯定会很多，恳请大家指正。现在正在学习的过程中。。。不定期更新，欢迎催更 :)</p><h3 id="library">library</h3><ul><li><a href="/Opt/OP_intro/">优化理论</a></li><li><a href="/Prop/Prop-intro">测度论和概率论</a></li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
